# Story 3.4: Multi-Level BOM Explosion

## Status

Done

## Executor Assignment

executor: "@dev"
quality_gate: "@architect"
quality_gate_tools: ["jest", "eslint", "tsc"]

## Story

**As a** production planner,
**I want** the MRP engine to perform multi-level BOM explosion using low-level coding,
**so that** gross requirements for all components at every BOM level are calculated correctly before netting.

## References

- FR-036: Multi-Level BOM Explosion (Low-Level Coding)
- [Source: architecture/4-backend-architecture.md#4.1 — mrp/engine/bom-explosion.service.ts]

## Acceptance Criteria

- [x] AC-1: BomExplosionService assigns low-level codes to all items in the BOM hierarchy
- [x] AC-2: RULE — Level 0 = finished products (tipoProduto = ACABADO); processing proceeds level by level (0, 1, 2, ...)
- [x] AC-3: RULE — If an item appears at multiple BOM levels, it is assigned the HIGHEST level number (deepest level)
- [x] AC-4: For each item at each period: the service calculates gross requirement, scheduled receipts, projected stock, and net requirement
- [x] AC-5: Gross requirement at level N+1 is derived from planned order releases at level N multiplied by BOM quantity (including loss percentage)
- [x] AC-6: Component gross requirement formula: `componentGross = parentPlannedQty * bom.quantidade * (1 + bom.perdaPercentual / 100)`
- [x] AC-7: The explosion processes all levels until all leaf nodes (purchased items) are reached
- [x] AC-8: BOM explosion handles shared components (same component used by multiple parents) by summing all parent requirements
- [x] AC-9: Circular BOM references are detected and reported as errors (reuse logic from Story 1.6)
- [x] AC-10: The output is a map of produtoId -> time-phased gross requirements array, ready for netting by NetRequirementService
- [x] AC-11: Unit tests >= 80% coverage with test cases for single-level, multi-level, shared components, and low-level coding

## Dev Notes

### Architecture References
- [Source: architecture/4-backend-architecture.md#4.1 — mrp/engine/bom-explosion.service.ts]
- [Source: architecture/6-data-architecture.md — bom table]

### Low-Level Coding Algorithm

```
1. Build adjacency list from BOM table (parent -> children)
2. For each finished product (level 0), traverse BOM tree
3. Track maximum depth for each item across all paths
4. Assign low-level code = max depth found for that item

Example:
  Product A (level 0)
    -> Component B (level 1)
      -> Component D (level 2)
    -> Component C (level 1)
      -> Component D (level 2)   <-- D appears at level 2 from both paths

  Product E (level 0)
    -> Component D (level 1)     <-- D also appears at level 1 here

  Result: D gets low-level code = 2 (highest level number)
```

### BOM Explosion Process

```
For level = 0 to maxLevel:
  For each item at this level:
    1. Get gross requirements (from MPS for level 0, or from parent explosion for level N)
    2. Apply netting: Net = Gross - Stock - Scheduled Receipts + SS
    3. Apply lot sizing (Story 3.5) to get planned order quantities
    4. For each child in BOM:
       childGross[period] += plannedOrderQty * bom.quantidade * (1 + perdaPercentual/100)
       childGross is offset by parent's lead time (planned order RELEASE, not receipt)
```

### Data Structures

```typescript
interface BomExplosionInput {
  // MPS demand for finished products (level 0)
  mpsRequirements: Map<string, TimePhasedDemand[]>;
  // BOM structure
  bomLines: BomLine[];
  // Stock positions
  stockByProduct: Map<string, number>;
  // Safety stock by product
  safetyStockByProduct: Map<string, number>;
}

interface BomLine {
  produtoPaiId: string;
  produtoFilhoId: string;
  quantidade: number;
  perdaPercentual: number;
}

interface LowLevelCodeMap {
  [produtoId: string]: number; // low-level code
}

interface ExplosionResult {
  lowLevelCodes: LowLevelCodeMap;
  grossRequirements: Map<string, TimePhasedDemand[]>;
}
```

### File Locations

**Backend (new files):**
- `apps/api/src/modules/mrp/engine/bom-explosion.service.ts`
- `apps/api/src/modules/mrp/engine/bom-explosion.service.spec.ts`
- `apps/api/src/modules/mrp/engine/interfaces/bom-explosion.interface.ts`

**Modified:**
- `apps/api/src/modules/mrp/mrp.module.ts` (register BomExplosionService)

### Testing Requirements

Test cases:
1. Single-level BOM: 1 finished product with 3 components, verify gross requirements
2. Multi-level BOM (3 levels): verify requirements cascade correctly with loss percentages
3. Shared component: component used by 2 different parents, verify requirements are summed
4. Low-level coding: item at multiple levels gets highest level number
5. Loss percentage: componentGross = parentQty * bomQty * (1 + loss/100)
6. Lead time offset: planned order release at parent offsets child requirement by LT
7. Circular BOM: detect and throw error
8. Empty BOM (purchased item with no children): no explosion needed

### Technical Constraints
- RULE: Level 0 = finished products; process level by level
- RULE: If item appears at multiple levels, use HIGHEST level number
- RULE: componentGross = parentPlannedQty * bom.quantidade * (1 + bom.perdaPercentual / 100)
- Only process active BOM lines (ativo = true)
- BOM validity dates (validoDesde, validoAte) must be checked against planning horizon

---

## Tasks / Subtasks

- [x] **Task 1: Define BOM explosion interfaces** (AC: 10)
  - [x] Create `bom-explosion.interface.ts` with all input/output interfaces (TimePhasedDemand, BomLineInput, BomExplosionInput, LowLevelCodeMap, BomExplosionResult)

- [x] **Task 2: Implement low-level coding algorithm** (AC: 1-3)
  - [x] Build adjacency list from active BOM lines
  - [x] DFS traversal to find max depth per item
  - [x] Handle shared components (take maximum level)
  - [x] ACABADO products start at level 0; orphan parents also treated as roots

- [x] **Task 3: Implement BOM explosion engine** (AC: 4-8)
  - [x] Level-by-level processing loop (0 to maxLevel)
  - [x] Component gross requirement calculation with loss percentage
  - [x] Shared component aggregation via mergeDemands (sum requirements from multiple parents)

- [x] **Task 4: Implement circular reference detection** (AC: 9)
  - [x] WHITE/GRAY/BLACK DFS coloring for cycle detection
  - [x] Throw BadRequestException with the circular path

- [x] **Task 5: Write comprehensive unit tests** (AC: 11)
  - [x] 37 test cases covering single-level, multi-level, shared components, low-level coding, circular detection, edge cases
  - [x] 99%+ statement coverage, 95%+ branch coverage, 100% function coverage

- [x] **Task 6: Register service in MRP module** (AC: all)
  - [x] Register BomExplosionService in MRP module providers and exports

---

## File List

| File | Action | Description |
|------|--------|-------------|
| `apps/api/src/modules/mrp/engine/interfaces/bom-explosion.interface.ts` | Created | BOM explosion interfaces (TimePhasedDemand, BomLineInput, BomExplosionInput, LowLevelCodeMap, BomExplosionResult) |
| `apps/api/src/modules/mrp/engine/bom-explosion.service.ts` | Created | Pure calculation engine — low-level coding, level-by-level explosion, shared component handling (391 lines) |
| `apps/api/src/modules/mrp/engine/bom-explosion.service.spec.ts` | Created | 37 unit tests (99%+ coverage) |
| `apps/api/src/modules/mrp/mrp.module.ts` | Modified | Added BomExplosionService provider/export |

---

## Dependencies

- Story 1.6: BOM CRUD (BOM data structure and circular reference detection)
- Story 3.2: Net Requirement Calculation Engine (netting logic used within explosion)
- Story 3.3: Stock Parameter Calculation (safety stock values needed for netting)

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2026-02-26 | 0.1 | Story created for Epic 3 — MRP Planning Engine | River (SM) |
| 2026-02-26 | 0.2 | Implementation complete — 3 files created, 1 modified, 37 tests (99% coverage) | Dex (Dev) |
| 2026-02-26 | 0.3 | QA Review PASS w/ CONCERNS — 11/11 AC, formulas correct, 1 medium concern (planned orders vs gross), 3 low | Quinn (QA) |
