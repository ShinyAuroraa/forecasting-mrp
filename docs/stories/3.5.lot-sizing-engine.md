# Story 3.5: Lot Sizing Engine

## Status

Done

## Executor Assignment

executor: "@dev"
quality_gate: "@architect"
quality_gate_tools: ["jest", "eslint", "tsc"]

## Story

**As a** production planner,
**I want** the MRP engine to apply lot sizing methods (Lot-for-Lot, EOQ, Silver-Meal) to net requirements,
**so that** planned order quantities are optimized according to each SKU's configured lot sizing policy while respecting minimum lot and purchase multiple constraints.

## References

- FR-037: Lot Sizing
- [Source: architecture/4-backend-architecture.md#4.1 — mrp/engine/lot-sizing.service.ts]

## Acceptance Criteria

- [x] AC-1: LotSizingService accepts net requirements (time-phased array) and a lot sizing method, returns planned order quantities
- [x] AC-2: Lot-for-Lot (L4L): planned order quantity = net requirement for each period (no aggregation)
- [x] AC-3: EOQ method: planned order quantity = EOQ value (from StockParamsService), ordered when net requirement > 0; if EOQ covers multiple periods, no orders until stock depletes
- [x] AC-4: Silver-Meal heuristic: aggregate future periods into current order as long as average cost per period decreases
- [x] AC-5: RULE — Apply constraints in order: (1) lote_minimo, (2) multiplo_compra roundup, (3) MOQ from supplier
- [x] AC-6: Constraint application: if planned qty < lote_minimo, round up to lote_minimo; then round up to nearest multiplo_compra; then ensure >= MOQ
- [x] AC-7: Planned order receipt is placed in the period where the net requirement exists; planned order release is offset back by lead time
- [x] AC-8: The service returns both planned order receipts and planned order releases (time-phased arrays)
- [x] AC-9: The lot sizing method for each SKU is read from Produto.politicaRessuprimento or a default configuration
- [x] AC-10: Unit tests >= 80% coverage with test cases for each lot sizing method and constraint combinations

## Dev Notes

### Architecture References
- [Source: architecture/4-backend-architecture.md#4.1 — mrp/engine/lot-sizing.service.ts]

### Lot Sizing Methods

**L4L (Lot-for-Lot):**
```
For each period t:
  if netRequirement[t] > 0:
    plannedOrderQty[t] = applyConstraints(netRequirement[t])
```

**EOQ:**
```
For each period t:
  if netRequirement[t] > 0 AND accumulatedFromPreviousEOQ <= 0:
    plannedOrderQty[t] = applyConstraints(EOQ)
    accumulatedFromPreviousEOQ = EOQ - netRequirement[t]
  else if netRequirement[t] > 0:
    accumulatedFromPreviousEOQ -= netRequirement[t]
    if accumulatedFromPreviousEOQ < 0:
      plannedOrderQty[t] = applyConstraints(abs(accumulatedFromPreviousEOQ) + roundUp)
      accumulatedFromPreviousEOQ = plannedOrderQty[t] - abs(prev_acc)
```

**Silver-Meal:**
```
Start with period t where netRequirement[t] > 0
  totalCost = orderingCost (K)
  bestAvgCost = K
  periods_covered = 1
  accumQty = netRequirement[t]

  For each future period t+j:
    holdingCostIncrement = h * netRequirement[t+j] * j
    totalCost += holdingCostIncrement
    avgCost = totalCost / (periods_covered + 1)
    if avgCost < bestAvgCost:
      bestAvgCost = avgCost
      accumQty += netRequirement[t+j]
      periods_covered++
    else:
      break  // stop aggregating

  plannedOrderQty[t] = applyConstraints(accumQty)
  Skip to first uncovered period
```

### Constraint Application Order (FR-037 RULE)

```typescript
function applyConstraints(qty: number, produto: Produto, fornecedor?: ProdutoFornecedor): number {
  let result = qty;

  // Step 1: lote_minimo
  if (result < produto.loteMinimo) {
    result = produto.loteMinimo;
  }

  // Step 2: multiplo_compra (round up to nearest multiple)
  if (produto.multiploCompra > 1) {
    result = Math.ceil(result / produto.multiploCompra) * produto.multiploCompra;
  }

  // Step 3: MOQ from supplier
  if (fornecedor?.moq && result < fornecedor.moq) {
    result = fornecedor.moq;
  }

  return result;
}
```

### Lead Time Offsetting

```
plannedOrderReceipt[t] = calculated qty (in the period of need)
plannedOrderRelease[t - LT] = same qty (offset back by lead time in periods)

If t - LT < 0 (release date is before planning horizon):
  flag as "past due" action message
```

### Data Structures

```typescript
interface LotSizingInput {
  produtoId: string;
  netRequirements: { period: Date; quantity: number }[];
  method: Lotificacao; // L4L | EOQ | SILVER_MEAL
  eoqValue: number;    // pre-calculated by StockParamsService
  loteMinimo: number;
  multiploCompra: number;
  moq: number;         // from supplier
  leadTimePeriods: number; // lead time in weekly periods
  orderingCost: number;  // K (for Silver-Meal)
  holdingCostPerUnit: number; // h (for Silver-Meal)
}

interface LotSizingOutput {
  plannedOrderReceipts: { period: Date; quantity: number }[];
  plannedOrderReleases: { period: Date; quantity: number }[];
}
```

### File Locations

**Backend (new files):**
- `apps/api/src/modules/mrp/engine/lot-sizing.service.ts`
- `apps/api/src/modules/mrp/engine/lot-sizing.service.spec.ts`
- `apps/api/src/modules/mrp/engine/interfaces/lot-sizing.interface.ts`

**Modified:**
- `apps/api/src/modules/mrp/mrp.module.ts` (register LotSizingService)

### Testing Requirements

Test cases:
1. L4L: each period gets exactly its net requirement (after constraints)
2. EOQ: order quantity = EOQ, covers multiple periods, next order only when depleted
3. Silver-Meal: aggregate periods while average cost decreases; stop when it increases
4. Constraint: lote_minimo applied (qty rounded up to loteMinimo)
5. Constraint: multiplo_compra applied (qty rounded up to nearest multiple)
6. Constraint: MOQ applied (qty rounded up to MOQ)
7. Constraint order: lote_minimo -> multiplo_compra -> MOQ applied sequentially
8. Lead time offset: planned release is LT periods before planned receipt
9. Past-due release: release date before planning horizon flagged
10. Zero net requirements: no planned orders generated

### Technical Constraints
- RULE: Apply constraints in order: (1) lote_minimo, (2) multiplo_compra roundup, (3) MOQ from supplier
- Lotificacao enum values: L4L, EOQ, SILVER_MEAL, WAGNER_WHITIN (Wagner-Whitin is future scope, not implemented in this story)
- All quantities are Decimal(12, 4) precision
- The service is pure (no DB writes — caller persists planned orders)

---

## Tasks / Subtasks

- [x] **Task 1: Define lot sizing interfaces** (AC: 1, 8)
  - [x] Create `lot-sizing.interface.ts` with LotSizingPeriod, LotSizingInput, PlannedOrder, LotSizingOutput

- [x] **Task 2: Implement constraint application function** (AC: 5, 6)
  - [x] applyConstraints(qty, loteMinimo, multiploCompra, moq): strict order
  - [x] Handle edge cases: constraints = 1 (no-op), qty = 0

- [x] **Task 3: Implement L4L method** (AC: 2)
  - [x] For each period with net > 0: planned qty = applyConstraints(net)

- [x] **Task 4: Implement EOQ method** (AC: 3)
  - [x] Track accumulated EOQ coverage across periods
  - [x] New order when coverage depleted; max(eoq, deficit); fallback for eoqValue <= 0

- [x] **Task 5: Implement Silver-Meal method** (AC: 4)
  - [x] Average cost per period with ordering and holding costs
  - [x] Aggregate while average cost decreasing; skip zero-demand periods

- [x] **Task 6: Implement lead time offsetting** (AC: 7)
  - [x] Planned order releases from receipts offset by lead time
  - [x] Past-due releases flagged with negative periodIndex

- [x] **Task 7: Implement main calculateLotSizing method** (AC: 1, 9)
  - [x] Route to L4L/EOQ/SILVER_MEAL; BadRequestException for unsupported
  - [x] Return both receipts and releases

- [x] **Task 8: Write comprehensive unit tests** (AC: 10)
  - [x] 49 tests covering all methods, constraints, lead time, edge cases
  - [x] 97%+ statement coverage, 96%+ branch coverage, 100% function coverage

---

## File List

| File | Action | Description |
|------|--------|-------------|
| `apps/api/src/modules/mrp/engine/interfaces/lot-sizing.interface.ts` | Created | Lot sizing interfaces (LotSizingPeriod, LotSizingInput, PlannedOrder, LotSizingOutput) |
| `apps/api/src/modules/mrp/engine/lot-sizing.service.ts` | Created | Pure calculation engine — L4L, EOQ, Silver-Meal + constraints + lead time offset (358 lines) |
| `apps/api/src/modules/mrp/engine/lot-sizing.service.spec.ts` | Created | 49 unit tests (97%+ coverage) |
| `apps/api/src/modules/mrp/mrp.module.ts` | Modified | Added LotSizingService provider/export |

---

## Dependencies

- Story 3.2: Net Requirement Calculation Engine (provides net requirements as input)
- Story 3.3: Stock Parameter Calculation (provides EOQ values)
- Story 1.3: Product CRUD (Produto.loteMinimo, multiploCompra fields)
- Story 1.5: Supplier CRUD (ProdutoFornecedor.moq field)

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2026-02-26 | 0.1 | Story created for Epic 3 — MRP Planning Engine | River (SM) |
| 2026-02-26 | 0.2 | Implementation complete — 3 files created, 1 modified, 49 tests (97% coverage) | Dex (Dev) |
| 2026-02-26 | 0.3 | QA Review PASS — 10/10 AC, all algorithms manually traced, 0 critical issues | Quinn (QA) |
